Папка с резервными копиями называется репозиторий. В нем храниятся изменения в виде отдельных файлов, которые сливаются в один.

"commit" - сохранить изменения в резервную папку с указанием в комментариях о проделанной работе.

"ветки" - когда мы хотим поработать над определенной фичей проекта в отдельной копии проекта

Поработав над фичей в отдельной ветке, можно слить готовый код с нашей основной веткой. При этом Git будет отслеживать файлы, которые принадлежат одновременно разным веткам. И, если изменения в них конфликтуют, то при слиянии Git укажет на это 

!первоначальные настройки сохраняются и после обновления версии

! Все настройки сохраняются в gitconfig. Данная утилита также определяет особенности операций в Git и, в целом, интерфейс системы

	$git config --list --show-origin
\\ выдает настройки системы

!Git автоматически оставляет имя автора куска кода и его email для связи

чтобы имя пользователя применялось ко всем проектам, с которыми вы работаете, в команду добавляется опция:

	--global:


	$git config --global user.name "MyUser"
	$git config --global user.email MyUser@mail.com

Если же в каком-нибудь конкретном проекте нужно изменить имя пользователя или его почту:

	$git config user.name "MyUser"
	$git config user.email MyUser@mail.com


!необходимо выбрать текстовой редактор для отправки сообщений в Git.

	$git config --global core.editor "'C:/Windows/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"

!Git создает для главную ветку с именем master, в которой будет хранится основной репозиторий с проектом. Есть возможность назначить любое имя для главной ветки

	$git config --global init.defaultBranch Gayb

	$git config --list
	//просмотр всех настроек
	$git config core.editor
	//конкретная настройка



!репозиторий хранится в специальной папке .git внутри вашего проекта. Для начала работы в папке с проектом нужно 

	$git init


!приступить к работе:
1) нужно изменить состояние файла с неотслеживаемого на отслеживаемый

	$git status 
	//статучс файлов

	$git add index.html (можно указать папку или точку)
	// включение отслеживания
*вновь добавленные файлы в отслеживаемую папку по умолчанию не отслеживаемые (просто повторить отслеживание папки)git add
* точка это все файлы в проекте

2) нужно указать в какой момент запоминать состояние файла для последующего коммита. При изменении отслеживаемого файла он добавится в разряд "модифицированных". Дело в том, что Git сохраняет (индексирует) именно текущее состояние файла. Под состоянием понимается текущий текст файла, а также создан он или удален. Если же файл изменен, то просто так его изменения не сохранятся (не проиндексируются) в Git. Для этого нужно снова выполнить команду add. Фактически эту команду следует рассматривать как добавление текущего состояния файла к новому коммиту.


Выполнение коммита:

	$git commit -m "мой первый коммит"
git add
	$git commit 
	// в этом случае комментарий будет в файле

!Файл может принимать три состояния: изменен (modified), индексирован (staged) и зафиксирован (committed)



Короткая форма статуса:
	$git status -short
	$git status -s

нет буквы 	unmodified
M 	modified
T 	file type changed
A 	added
D 	deleted
R 	renamed
C 	copied
U 	updated but unmerged

!Игнорирование файлов:
делается с помощью специального файла .gitignore, размещаемого в папке с проектом. В этом файле на каждой строке нужно писать путь к файлу или папке, которые мы хотим игнорировать
/debug.log - файл в корне репозитория
debug.log - файлы и в подпапках
logs/ - папки
**/logs - все папки содержащую такую подпапку в пути
**/logs/debug.log - ля сопоставления файлов на основе их имени и имени родительской папки:
*.log - Одна звездочка — это подстановочный знак, который может соответствовать как нескольким символам, так и ни одному


!Просмотр изменений после индексации

	$git diff

!Пропуск индексации измененных файлов и сразу в коммит

	$git commit -a


! Удаление файлов 
При работе с Git нельзя вручную удалять файлы из папки с проектом. Если сделать это, то после проверки командой status, он будет отображаться в категории 'Changes not staged for commit' как измененный, но не проиндексированный файл. 

	$git rm text.txt
	\\полностью удаляет файл

!Переименование файлов

	$git mv old.txt new.txt


!Перемещение файлов 
Команда mv также используется для перемещения файлов.

	$git mv old/file.txt new/file.txt

! Просмотр истории коммитов
	
	$git log
	//Можно вывести не все, а только заданное количество последних коммитовля этого к команде log нужно добавить флаг с числом

	$git log -3


! Флаги истории коммитов
K команде log можно добавлять специальные флаги

-p 	Показывает разницу в изменениях каждого коммита.

--stat 	Отображает статистику для коммита.

--shortstat 	Показывает количество изменений/вставок/удалений при применении команды --stat.

--name-only 	Отображает информацию о коммите и имена измененных файлов.

--name-status 	Выводит сообщение о списке файлов, которые были изменены, в т.ч. добавлены и удалены.

--relative-date 	Отображает дату применения изменений в относительном формате (например, '1 day ago').

--pretty 	Меняет формат вывода истории коммитов: =oneline в одну строку, =full - полный и =short - краткий вывод.

--graph 	Показывает ветвление веток Git и историю их слияний.


!Редактирование коммита
Когда коммит отправлен неверно есть возможность отправить исправленный коммит, который будет принят вместо предыдущего коммита. Для этого сначала вносите правки, индексируете их, а затем

	$git commit --amend

!Отмена индексации файла
используется команда restore, с флагом --staged, после которого добавляется имя файла

	$git restore --staged file.txt

!Отмена изменений в файле
вернуть его в исходный видсначала внесем изменения в файл file.txt и отследим его статус git status
Aайл file.txt получил статус modified.Теперь вернем файл в исходное состояние

	$git restore file.txt


!Псевдонимы команд
псевдоним для команды commit

	$git config --global alias.com commit
	//Теперь для создания коммита достаточно ввести
	$git com


!Ветки. 
-позволяют вести параллельную работу над проектом, переключаясь по мере необходимости между ветками, решая различные задачи. По умолчанию у нас есть одна ветка - master. Обычно эту ветку считают основной. При создании новой ветки в ней будут копии файлов  проекта. В них код, а затем, когда задача будет выполнена, код  новой ветки сольем с основной веткой. Таким образом, можно параллельно вести работу над несколькими проблемами. При этом, при переключении между ветками, Git сам меняет файлы в папке с вашим проектом и  файлы будут исчезать, а показываться другие. Также будут меняться тексты файлов, если они отличаются от ветки к веткеогда вы в терминале будете менять ветку, то ваши файлы и тексты в них будут меняться в соответствии с веткой. Физически! Сами! Прям в открытом редакторе текст вашего файла будет меняться на другой!

!Создание новой ветки
создаются с помощью команды branch

	$git branch NAME
	//При этом будет создана новая ветка, однако переключения на нее не произойдет.

!Просмотр веток
Для того, чтобы просмотреть все ветки, которые есть в репозитории

	$git branch


!Переключение веток
Для этого используется команда checkout. После указывается имя ветки

	$git checkout test

Можно также использовать синоним switch:
git switch test

!Слияние веток
содержимое побочной ветки вливается в основую. Это делается с помощью команды merge

*Пусть есть ветка master и ветка test.

Переключимся на ветку test, сделаем изменения в файле, проиндексируем его и сохраним коммит:

	$git switch test
	$git add file.txt
	$git commit -m 'commit from test'

После этого вернемся в ветку master:

	$git switch master

Вольем теперь в нашу ветку master содержимое ветки test:

	$git merge test

После выполнения этой команды Git попросит нас ввести комментарий к слиянию.На самом же деле мы не сливаем ветки, а вливаем содержимое одной ветки в другую



!Конфликт при слиянии веток в Git

Если в каждой из веток мы изменяли один и тот же файл. Мы изменили и сделали коммит на один тот же файл file.txt. А затем применили команду слияния:

	$git merge test

	//В результате увидим ошибку:
	Auto-merging file.txt
	CONFLICT (content): Merge conflict in file.txt
	Automatic merge failed; fix conflicts and then commit 
	the result. 

	Кроме того, в изменяемом файле мы увидим маркеры конфликта:
	<<<<<<< HEAD
	тут будут написаны изменения ветки master
	=======
	тут будут написаны изменения ветки test
	>>>>>>> test

Для разрешения конфликта необходимо привести содержимое файла к общему виду, предварительно удалив (руками в редакторе!) все обозначения конфликта, которые оставил в нем Git.

После этого, проиндексируем наш файл и сделаем коммит в ветке master, в которой мы сейчас находимся:
git add file.txt
git commit -m "слияние"

Только после этого мы можем переключиться на вторую ветку test и проделать все те же операции, что и в ветке master, в том числе и заменить содержимое файла file.txt на то же, что и в первой ветке:
git add file.txt
git commit -m "слияние"

Теперь мы можем снова переключиться на основную ветку и влить в нее вторую:
git switch master
git merge test


!Удаление веток
Git не удаляет ветки при слиянии. Если ветка стала не нужна:

	$git branch -D test
	//Deleted branch test (was c440a0b).

!Переименование веток
через пробел указывается исходное и новое имена:
	
	$git branch --move old new

!Просмотр последнего коммита веток
какие коммиты были сделаны последними в каждой из существующих веток
	
	$git branch -v



!Слитые ветки

Слитые ветки - это ветки, в которые осуществлялось вливание. Можно посмотреть эти ветки с помощью:

	$git branch --merged

Для вывода не слитых веток, либо тех, что при слиянии были вспомогательными, используем следующую команду:
git branch --no-merged


!Простое перебазирование коммитов

!При перебазировании история коммитов обеих веток, в отличие от слияния, будет выглядеть более линейной и простой. В Git слияние, происходит как трехстороннее объединение последних изменений двух сливаемых веток и самого нового снимка родительской ветки. Перебазирование предполагает применение изменений из одной ветки (текущей) поверх другой ветки.

	$git branch test
	$git switch test
	$git add file.txt
	$git commit -m "commit from branch test"

	$git checkout test
	$git rebase master
	//переключимся на тест и перебазируем в мастер

* Процесс перебазирования: сначала Git делает снимок родительской ветки master, который сохраняется во временном файле. Затем текущая ветка test вставляет свои изменения после самого последнего коммита ветки master. Теперь история коммитов основной ветки будет выглядеть так:

После перебазирования история коммитов ветки test также будет выглядеть аналогично ветке master.

Затем этого можно перейти на ветку master и выполнить слияние перемоткой, т.е. master снова станет главной и включит в себя все изменения с ветки test:
git merge test


!Внешние репозитории:
!Добавление: придумать имя внешнего репозитория и привязать это имя к ссылке на репозиторий

	$git remote add origin https://github.com/user/project.git
	//В результате добавления появится имя с помощью которого вы будете обращаться к этому внешнему репозиторию


!Просмотр информации внешнего репозитория
можно получить некоторую информацию о репозитории с помощью команды remote show, после который указывается имя внешнего репозитория

	$git remote show origin


!Получение имени внешнего репозитория

	$git remote

!Адреса внешнего репозитория
адреса для чтения и записи данного внешнего репозитория

	$git remote -v
	//В сообщении увидим имя которое дали внешнему репозиторию и адрес для чтения проекта - fetch и записи - push
origin https://github.com/user/my-project (fetch)
origin https://github.com/user/my-project (push)

!Переименование внешнего репозитория
исходное и новое имя

	$git remote rename old new


!Удаление внешнего репозитория
удалить связь между именем репозитория и его ссылкой. Сам репозиторий по-прежнему останется

	$git remote rm origin


!Отправка данных во внешний репозиторий
Сначала подготовим и отправим наш коммит для внешнего репозитория на сайте GitHub.

Сделаем файл test.txt и проиндексируем его:

	$git add test.txt

Выполним коммит:

	$git commit -m "first commit"

А теперь отправим наш коммит во внешний репозиторий. Для этого нужно использовать команду push, в которой после флага -u через пробел указывается имя удаленного репозитория и имя ветки, которую мы отправляем:
	
	$git push -u origin master

После выполненения команды, терминал попросит вас ввести ваш логин на GitHub и токен, который мы создали в предыдущих уроках (вводить нужно только первый раз). После ввода токена все ваши коммиты, которых еще нет на сервере, будут отправлены.

Если после этого вы на сайте GitHub зайдете в ваш проект, вы увидите там файлы с вашим кодом. 


!Отправка в другую ветку

	$git push origin master:remote_branch

!Получение изменений из внешних репозиториев

	!git fetch origin

Данная команда скопирует все изменения, сделанные во внешнем репозитории/ При этом изменения не появятся сразу в наших файлах, а попадут в специальную ветку. Имя этой ветки будет строится по следующему принципу: имя внешнего репозитория, а потом через слеш имя ветки. В нашем случае это будет origin/master.Чтобы изменения появились в файлах нашего проекта, нужно влить изменения в нашу ветку. Для этого, находясь в ветке master, выполним команду на слияние:
git merge origin/master

!Стягивание данных из внешних репозиториев

	$git pull origin master
	//данные сразу перенусться в папку

	$git pull 
	//короткая форма

!Удаление внешних веток
удалить ненужные больше внешние ветки

	$git push origin --delete test

!Клонирование внешнего репозитория

Проекты, размещенные на GitHub, можно клонировать. Это значит, что вы можете стянуть себе весь код этого проекта. Это может быть как ваш проект, так и чужой. После клонирования вы сможете вносить изменения в этот проект у себя на локалке

	$git clone https://github.com/some-project

В начале процесса клонирования создается пустой каталог с именем вашего проекта, затем в нем инициализируется репозиторий .git. В него копируются все файлы из исходного проекта. Если мы хотим, чтобы имя нашего клона отличалось от названия исходной папки, то в конце команды добавляем новое имя:
git clone https://github.com/some-project my-project




